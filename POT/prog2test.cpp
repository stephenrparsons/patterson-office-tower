#include <iostream>
#include <string>
#include <vector>

using namespace std;

// ++++++++++++++++++++???IIIIIII???????+++?????+++++???????IIIII??IIIIIIIIIIII????
// +++++++++++++++++++++?????I??IIIIII?++++++??I?++++???II?????????????IIIIIIII7III
// +++++++++++??++++++??????III?????III?+++++++?I??III++++?????????????IIIIIIIIIIII
// ++++++++++++++????++????III?III???+??++++++??????I?????????III??IIIIII??IIIIIIII
// ????II????I??++++???????????IIII?III??++++++?+?++?+++?????III???????????????????
// III???++++++++++++++++++++??????IIIII?III???I??IIIIII77II7I??++++++++++??+++????
// ++???????++++++++++++++++++++++++??II77III???????III??II77777?+++++++++++++++++?
// ??++++++?????++??++++++++++++++?++?????I????????+++?????II7I7II?++++++++++++++++
// +??+++++++++????+++++++++++++++??????????????I???????+++++???+???+++++++++++++++
// +??+++++??++++++++++?++++++++++++???+++???????+?I???I??+++++++++++++++++++++++++
// +?+++++++++++++++++++???+++?++++?++?????+?++????????++??+++++++++????+++++++++++
// ??++??+???++????+???????+??+??+??????????II?I??I??????I???+??????????????+++++++
// ????????????????????????????????????????????????????????????????????????????????
// ?????????????????????????????????????+??+??++++?????????????????????????????????
// ????????????????????+????????????????????????=++=++?????+????+????+????+?????+++
// ??????????????????????????????????????????+:~:,,,,,:~=???????????????????????++?
// ?????????????????????????????????????????+~,,,,,,,,,:,~?????????????????????????
// ??????????????????????????????????????????:,,,,..,,,,,:?????????????????????????
// +++????????+?????????????????????????????+,,.,,,,,,,,,:?????????????????????????
// ~~~~~~~~~==~~~~+++++++++++++++++?++++?++++,,,:,:,,:~~~,++???????+?+?+???????????
// ~~~~~~~~~:~~~:~~~~~:~~~~~~~~~~~~~~~~~~~~~~,,:,,,:::~=~~+++++++++++++++++++++++++
// ~~~::~~:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,::,,,~,,,,~~~~~~~~~~~~~~~~~~~~~~~~:~
// :::~:~~~~~~::::::~~~:~~~~~~~~~~~~~~~~~~~~~:::::,,~~==~~====~~~~~~~~~~~~~~~~~~~~~
// ~~~:~~~~~~~~~:~~:~~:~~~~~~~~~~~~~~~~~~~~~~~:::,,,,:~~~===~~~~~~~~~~~~~~~~~~~::~~
// ::~~~~~~~~~~~~:~~~~~~~~~~~:~~~~~~~~=~~~~~:,:::,,,,,~~~==~~~~~=~=~~~~~~~~~~~~~:~~
// ~~~~~~~:::~::~~::~~~~~~~~~~~~~~~~~~~~::::,,,,,,:::~=====~======~~~~~~~~~~~~~~:~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=~::,,,,,,,,,~~:~~~~====~~~~~~~:~~~~~=~~~~~~
// ~==~~~~~~~~~~~~~~~~~~~~~=+?I?==++~~~====::,,,,,:~=~=~:~~~~=+??II77I777I?77II7I??
// =~=~~==~+=++=+++++++++++++==+====::~~==+=::~::,~~~~~:::::~==++::~~~~~~~~~~~~:~~~
// ~~~~~:::::::~~~:~~~~::~~~~~~~~:~:::~~=++==~~~~::::::,,,,,,::~===~~~~:~~~~~~:::~:
// ~~~~~~~~::~~:~~~::~~:~~~~~~~~~~~::~~====~~~~~~~::::,,,,,,,,,::~~===:::~::~~:::::
// ~~~~~~~:::~~:~~~~~~~~~::~~~~~~~::,::~===~~~~~:::::,,,,::::,,,,,:::~~=::~:~::::~~
// ~::~::~~~~~~~~~~:~~:::::~~:~~~::,,:::~~==:~::,,,,,,::~~:::::::::,,,:~==~~::::::~
// ~~~~~~~~~~~~~:::::~~:::::::~~~~,,,::::~~====~,,,,:~~::::~:,,,,,::,,:~==+:::~::::
// ~~~~~~~~~~~~~:~~~~~~~~~~~~:~~~~:,,,::::~~======,~~~~~~~,,,..,,,,,,:~=====:~~:::~
// :~~~~~~~:::::~~~~~:~~~~:::~:::::,,,,,,,::~~======:,,,,......,.,,,:~======:::~~~~
// ~~::~~~~~~~:~~~~~~~~~::::~~~~~::,,,,,,,,,:~~~=======,.........,,~=======~~::::::
// ::::~~~~~~~~~~~~~~~~~~~~~~~:~~:,,,,,,,.,,,,::~~=======~....:~========~~~:~~~~:::
// ~~~~:~~~~~~:::::~::::~:~::::::,.,,,.,.....,,,,:::~~~====~~=~=======~:::~::~:::::
// ~~~~~~~~~~~~:~~~~:~::~~~~~~~~:,,,......,...,,...,,,,::::~~~~:====~::::::::::::::
// :::::,:::::::,:::::::::~~~~~~,,,,........,,,,,::,,,...,,:~~~~:=~,,,:~~~:~:~:~~~~
// :,:,,::::::::::,::::,::::,:::,,............,,.,,,:,,....,,:,~~,,,,,::~~,::::::::
// ::::,,::::::::,::,:,,,,,,,,,,,.............,,..,,::~~:...,,,~==,,,.,,,,~~~::::::
// ::::::::::~::::::,,,,,,,,,,,,,..............,,.,,::~~~~:::,.,~~.,,:~~=~,::::::::
// :,::,,::::,,,,,,,,,,,,,,,,,,,,,..............,,,,,::~:~,:::.,,~.,,::~==,::~::::,
// ,:,:::::::,,,,:,,,,,,,,,,,,,,,,,.............,,,,,,::~=~:,,,,,:.,,::~==:,,,,::~:
// ::,,::::::::,,,,,,,,,,,,,,,,,,,,,,,..........,,,,,,,,:~=~,,..,,..,,:~~=:~:,:,,,:
// ~:::::~~::::::,,,,,,,,,,,,,,,,,,,,,,,,,.,,,,..,....,,,:~~=,.,,,,.,,,:~=:,::::,,:
// ~:::::::::::::::::::,::::,,,,,,,,,,,,,,,,,,....,,..,,,,:~~~:,,,,.,,,,~~:,::::::~
// ::~~:::::::~::::~::::~::~~:,,,,:::,,,,,,,,,,,..,,,,..,,,,:~~~,,,,.,,::~~,,,,,,,,
// ~::~~~:::::::::::~:::~::::::,,::~~::,,,,,,,,,,,,.,,.,..,,,::~~,,,.,,:~~~~,,,,,,,

#include "DungeonLevel.h"

// Practicum 8 : Implement this method
void markPosition(vector<string> & vLevel, int x, int y)
{
	if ( x < 0 || x > vLevel[0].length() - 1 )
	{
		return;
	}
	if (y < 0 || y > vLevel.size() - 1)
	{
		return;
	}
	if (vLevel[y][x] != '.' && vLevel[y][x] != '#')
	{
		return;
	}
	vLevel[y][x] = 'X';
	markPosition(vLevel, x-1, y);
	markPosition(vLevel, x+1, y);
	markPosition(vLevel, x, y+1);
	markPosition(vLevel, x, y-1);
}


bool testLevel(vector<string> & vLevel)
{
	// Display the initial state
	cout << "Initial state: " << endl;
	for( auto it = vLevel.begin(); it != vLevel.end(); it++ )
	{
		cout << (*it) << endl;
	}

	cout << endl;

	int x = -1;
	int y = -1;

	// pick a starting position
	for( int i = 0; i < vLevel.size(); i++ )
	{
		for( int j = 0; j < vLevel[i].size(); j++ )
		{
			if( vLevel[i][j] == '.' || vLevel[i][j] == '#' )
			{
				// Starting position just has to be a room or
				// tunnel tile
				x = j;
				y = i;
			}
		}
	}

	if( x == -1 )
	{
		cout << "Unable to find starting position!" << endl;
		return false;
	}
	
	// Call the function which actually marks the tiles -- it should mark
	// the starting tile, then any adjacent to it, etc -- so after it's done,
	// everything that can be connected to the starting tile should be
	// marked.
	markPosition(vLevel, x, y);

	bool bCorrect = true;

	cout << endl << "Marked state: " << endl;
	// Outer loop
	for( auto itOuter = vLevel.begin(); itOuter != vLevel.end(); itOuter++ )
	{
		// Inner loop
		for( auto itInner = (*itOuter).begin(); itInner != (*itOuter).end(); itInner++ )
		{
			cout << (*itInner);


			// Now, test if it's a room/tunnel tile -- if it's still
			// one after we've 
			if( (*itInner) == '.' || (*itInner) == '#' )
			{
				bCorrect = false;
			}
		}

		cout << endl;
	}

	cout << endl;

	if( !bCorrect )
	{
		cout << "Unreached room/tunnel tile detected!" << endl;
	}


	return bCorrect;

}

int main(int argc, char * argv[])
{
	for(int i = 0; i < atoi(argv[1]); i++)
	{
		DungeonLevel level;
		level.generateLevel();
		vector<string> levelString = level.stringFormat();
		testLevel(levelString);
	}

	return 0;
}
